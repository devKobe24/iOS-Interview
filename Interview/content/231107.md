# iOS ë©´ì ‘ ì§ˆë¬¸ ë° ë‹µë³€ ì‹œë¦¬ì¦ˆ (5) ğŸ¤”

---

## Q. ê°•í•œ ìˆœí™˜ ì°¸ì¡°(Strong Reference Count)ë€ ë¬´ì—‡ì¼ê¹Œìš”?

ê°•í•œ ìˆœí™˜ ì°¸ì¡°ëŠ” ë‘ ê°ì²´ë‚˜ ì—¬ê±° ê°ì²´ê°€ ì„œë¡œë¥¼ ê°•í•œ ì°¸ì¡°(strong reference)ë¡œ ì°¸ì¡°í•˜ê³  ìˆì–´ì„œ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ì ˆëŒ€ë¡œ 0ì´ ë˜ì§€ ì•ŠëŠ” ìƒí™©ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

## Q. ê·¸ë ‡ë‹¤ë©´ ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ìƒê¸°ë©´ ì–´ë–¤ ë¬¸ì œê°€ ë°œìƒí• ê¹Œìš”?

ë©”ëª¨ë¦¬ ëˆ„ìˆ˜(memory leak)ë¡œ ì´ì–´ì§ˆ ìˆ˜ ìˆìœ¼ë©°, ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì„±ëŠ¥ ì €í•˜ë‚˜ ë¹„ì •ìƒ ì¢…ë£Œë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•˜ë©´, ê´€ë ¨ ê°ì²´ë“¤ì´ ì„œë¡œë¥¼ ì°¸ì¡°í•˜ê³  ìˆì–´ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ì ˆëŒ€ë¡œ 0ì´ ë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## Q. ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ì¼ì–´ë‚˜ëŠ” ê²ƒì„ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆì„ê°€ìš”?

ê°•í•œ ìˆœí™˜ ì°¸ì¡°ì¼ ê²½ìš° ê´€ë ¨ ê°ì²´ë“¤ì´ ì„œë¡œë¥¼ ì°¸ì¡°í•˜ê³  ìˆì–´ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ ì ˆëŒ€ë¡œ 0ì´ ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ARC(Automatic Reference Counting)ë¡œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

Swiftì—ì„œëŠ” ARCê°€ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•˜ëŠ”ë°, ARCëŠ” ê°ì²´ì˜ ì°¸ì¡° ì¹´ìš´ë¥¼ ì¶”ì í•˜ì—¬ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ 0ì´ ë˜ë©´ í•´ë‹¹ ê°ì²´ë¥¼ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

## Q. ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ì— ëŒ€í•´ì„œ ë§ì”€í•´ì£¼ì„¸ìš”.

ë„¤, 3ê°€ì§€ì˜ ê²½ìš°ë¥¼ ë§ì”€ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ë¨¼ì €, í´ë¡œì €(Closure) ë˜ëŠ” ë¸”ë¡(Blocks) ë‚´ì—ì„œ selfë¥¼ ì°¸ì¡°í•  ë•Œì…ë‹ˆë‹¤.

í´ë¡œì €ëŠ” ìì‹ ì´ ì •ì˜ëœ ì»¨í…ìŠ¤íŠ¸ì˜ ëª¨ë“  ë³€ìˆ˜ë¥¼ ìº¡ì³í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
ë§Œì•½ í´ë¡œì € ë‚´ì—ì„œ `self` ì¦‰, í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°•í•œ ì°¸ì¡°ë¡œ ìº¡ì³í•  ê²½ìš°, ê·¸ í´ë¡œì €ê°€ ì¸ìŠ¤í„´ìŠ¤ì˜ ì†ì„±ìœ¼ë¡œ
ì €ì¥ë˜ì–´ ìˆìœ¼ë©´ ì¸ìŠ¤í„´ìŠ¤ì™€ í´ë¡œì € ê°„ì— ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•©ë‹ˆë‹¤.

ë‘ ë²ˆì§¸ëŠ”, ë‘ ê°ì²´ê°€ ì„œë¡œë¥¼ ê°•í•˜ê²Œ ì°¸ì¡°í•˜ëŠ” ê²½ìš°ì…ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, `class A`ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ `class B`ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°•í•˜ê²Œ ì°¸ì¡°í•˜ê³ ,
ë™ì‹œì— `class B`ì˜ ì¸ìŠ¤í„´ìŠ¤ë„ `class A`ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°•í•˜ê²Œ ì°¸ì¡°í•˜ë©´ ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ ë¶€ëª¨-ìì‹ ê´€ê³„ì—ì„œ ë°œìƒí•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ë¶€ëª¨ ê°ì²´ê°€ ìì‹ ê°ì²´ë¥¼ ê°•í•˜ê²Œ ì°¸ì¡°í•˜ê³ , ìì‹ ê°ì²´ê°€ ë¶€ëª¨ë¥¼ `delegate` ë˜ëŠ” `ë‹¤ë¥¸ ë°©ì‹`ìœ¼ë¡œ ê°•í•˜ê²Œ ì°¸ì¡°í•  ë•Œ ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## Q. ê·¸ë ‡ë‹¤ë©´ ê°•í•œ ìˆœí™˜ ì°¸ì¡°ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆì„ê¹Œìš”? ì•Œê³  ìˆëŠ” ë°©ë²•ì„ ì•Œë ¤ì£¼ì‹œê² ìŠµë‹ˆê¹Œ?

ë„¤, ì œê°€ ì•Œê³  ìˆëŠ” 3ê°€ì§€ì˜ ë°©ë²•ì— ëŒ€í•´ì„œ ì„¤ëª…ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ë¨¼ì € `ì•½í•œ ì°¸ì¡°(Weak Reference)`ë¥¼ í™œìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```swift
class Parent {
    var child: Child?
}

class Child {
    weak var parent: Parent?
}
```

`weak` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠëŠ” ì•½í•œ ì°¸ì¡°ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì•½í•œ ì°¸ì¡°ëŠ” ì°¸ì¡°í•˜ê³  ìˆëŠ” ê°ì²´ê°€ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë  ë•Œ ìë™ìœ¼ë¡œ `nil`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.

ë‘ë²ˆ ì§¸ ë°©ë²•ì€ `ë¹„ì†Œìœ  ì°¸ì¡°(Unowned Reference)`ë¥¼ í™œìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```swift
class Customer {
    let name: String
    var card: CreditCard?
    
    init(name: String) {
        self.name = name
    }
}

class CreditCard {
    unowned let customer: Customer
    let number: UInt64
    
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
}
```

`unowned` í‚¤ì›Œë“œëŠ” ì°¸ì¡° ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠëŠ” ë˜ ë‹¤ë¥¸ ë°©ë²•ì…ë‹ˆë‹¤.
ê·¸ëŸ¬ë‚˜ `unowned` ì°¸ì¡°ëŠ” ì°¸ì¡°í•˜ê³  ìˆëŠ” ê°ì²´ê°€ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œëœ í›„ì—ë„ `nil`ë¡œ ì„¤ì •ë˜ì§€ ì•Šìœ¼ë©°,
í•´ì œëœ ê°ì²´ì— ì ‘ê·¼í•˜ë ¤ê³  í•  ë•Œ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤ëŠ” íŠ¹ì§•ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ ì°¸ì¡°í•˜ê³  ìˆëŠ” ê°ì²´ê°€ ì°¸ì¡°ìì™€ ê°™ì€ ìˆ˜ëª… ë˜ëŠ” ë” ê¸´ ìˆ˜ëª…ì„ ê°€ì§ˆ ë•Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

ë§ˆì§€ë§‰ ë°©ë²•ì€ `í´ë¡œì € ë‚´ ìº¡ì³ ë¦¬ìŠ¤íŠ¸(Capture List in Closures)`ë¥¼ í™œìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

```swift
class MyClass {
    var property: String
    
    init(property: String) {
        self.property = property
    }
    
    func doSomething() {
        someAsyncMethod { [weak self] result in
            guard let strongSelf = self else {
                return
            }
            strongSelf.property = result
        }
    }
}

```

í´ë¡œì € ë‚´ì—ì„œ `self`ë¥¼ ì°¸ì¡°í•  ë•Œ ê°•í•œ ìˆœí™˜ ì°¸ì¡°ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê·¸ëŸ´ ê²½ìš° í´ë¡œì € ìº¡ì³ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ í´ë¡œì €ê°€ `self`ë¥¼ `weak` ë˜ëŠ” `unowned`ë¡œ ì°¸ì¡°í•˜ë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

Sure, here's the translation of the provided text into English:

## Q. What is a strong reference cycle?

A strong reference cycle refers to a situation where two or more objects are referencing each other with strong references, making it so that their reference counts never drop to zero.

## Q. So what problems can occur if a strong reference cycle is formed?

It can lead to memory leaks, which may cause the application to perform poorly or terminate unexpectedly.

This happens because the involved objects keep referencing each other, preventing their reference counts from ever dropping to zero, hence they are never deallocated from memory.

## Q. How can you tell if a strong reference cycle has occurred?

Strong reference cycles can be identified with Automatic Reference Counting (ARC), as the reference counts of the involved objects do not drop to zero due to mutual strong references.

In Swift, ARC manages memory by tracking the reference counts of objects, deallocating an object when its reference count drops to zero.

## Q. Please talk about the situations in which strong reference cycles occur.

Sure, I will mention three situations.

First is when self is referenced within a closure or blocks.

Closures have the ability to capture all variables in their defining context. If a closure within an instance captures `self` with a strong reference, and that closure is stored as a property of the instance, a strong reference cycle between the instance and the closure is created.

Second, when two objects strongly reference each other.

For example, if an instance of `class A` strongly references an instance of `class B`, and `class B` simultaneously strongly references an instance of `class A`, a strong reference cycle is formed.

Lastly, it occurs in parent-child relationships.

For instance, a parent object strongly references a child object, and the child object strongly references the parent as a `delegate` or in another manner, leading to a strong reference cycle.

## Q. Then, are there ways to prevent strong reference cycles? Can you tell me about the methods you know?

Yes, I'll explain the three methods I know.

First is using `weak references`.

By using the `weak` keyword, you can create a weak reference that does not increase the reference count. Weak references automatically become `nil` when the object they reference is deallocated from memory.

The second method is using `unowned references`.

The `unowned` keyword is another way to not increase the reference count. However, unlike weak references, `unowned` references do not become `nil` after their object is deallocated, which can lead to runtime errors if you attempt to access the deallocated object. Therefore, it should be used when the referenced object has the same or longer lifespan than the referencer.

The last method is using `capture lists in closures`.

Strong reference cycles can occur when `self` is referenced inside a closure. In such cases, you can use a capture list to ensure that the closure references `self` as `weak` or `unowned`.
