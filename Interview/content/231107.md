# iOS 면접 질문 및 답변 시리즈 (5) 🤔

---

## Q. 강한 순환 참조(Strong Reference Count)란 무엇일까요?

강한 순환 참조는 두 객체나 여거 객체가 서로를 강한 참조(strong reference)로 참조하고 있어서 참조 카운트가 절대로 0이 되지 않는 상황을 의미합니다.

## Q. 그렇다면 강한 순환 참조가 생기면 어떤 문제가 발생할까요?

메모리 누수(memory leak)로 이어질 수 있으며, 애플리케이션의 성능 저하나 비정상 종료를 일으킬 수 있습니다.

강한 순환 참조가 발생하면, 관련 객체들이 서로를 참조하고 있어 참조 카운트가 절대로 0이 되지 않아 메모리에서 해제되지 않기 때문입니다.

## Q. 강한 순환 참조가 일어나는 것을 어떻게 알 수 있을가요?

강한 순환 참조일 경우 관련 객체들이 서로를 참조하고 있어 참조 카운트가 절대로 0이 되지 않기 때문에 ARC(Automatic Reference Counting)로 알 수 있습니다.

Swift에서는 ARC가 메모리 관리를 담당하는데, ARC는 객체의 참조 카운를 추적하여 참조 카운트가 0이 되면 해당 객체를 메모리에서 해제하기 때문입니다.

## Q. 강한 순환 참조가 발생하는 경우에 대해서 말씀해주세요.

네, 3가지의 경우를 말씀드리겠습니다.

먼저, 클로저(Closure) 또는 블록(Blocks) 내에서 self를 참조할 때입니다.

클로저는 자신이 정의된 컨텍스트의 모든 변수를 캡쳐할 수 있는 기능을 가지고 있습니다.
만약 클로저 내에서 `self` 즉, 현재 인스턴스를 강한 참조로 캡쳐할 경우, 그 클로저가 인스턴스의 속성으로
저장되어 있으면 인스턴스와 클로저 간에 강한 순환 참조가 발생합니다.

두 번째는, 두 객체가 서로를 강하게 참조하는 경우입니다.

예를 들어, `class A`의 인스턴스가 `class B`의 인스턴스를 강하게 참조하고,
동시에 `class B`의 인스턴스도 `class A`의 인스턴스를 강하게 참조하면 강한 순환 참조가 발생합니다.

마지막으로 부모-자식 관계에서 발생합니다.

예를 들어, 부모 객체가 자식 객체를 강하게 참조하고, 자식 객체가 부모를 `delegate` 또는 `다른 방식`으로 강하게 참조할 때 강한 순환 참조가 발생할 수 있습니다.

## Q. 그렇다면 강한 순환 참조를 방지할 수 있는 방법이 있을까요? 알고 있는 방법을 알려주시겠습니까?

네, 제가 알고 있는 3가지의 방법에 대해서 설명드리겠습니다.

먼저 `약한 참조(Weak Reference)`를 활용하는 방법입니다.

```swift
class Parent {
    var child: Child?
}

class Child {
    weak var parent: Parent?
}
```

`weak` 키워드를 사용하면 참조 카운트를 증가시키지 않는 약한 참조를 생성할 수 있습니다.
약한 참조는 참조하고 있는 객체가 메모리에서 해제될 때 자동으로 `nil`로 설정됩니다.

두번 째 방법은 `비소유 참조(Unowned Reference)`를 활용하는 방법입니다.

```swift
class Customer {
    let name: String
    var card: CreditCard?
    
    init(name: String) {
        self.name = name
    }
}

class CreditCard {
    unowned let customer: Customer
    let number: UInt64
    
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
    }
}
```

`unowned` 키워드는 참조 카운트를 증가시키지 않는 또 다른 방법입니다.
그러나 `unowned` 참조는 참조하고 있는 객체가 메모리에서 해제된 후에도 `nil`로 설정되지 않으며,
해제된 객체에 접근하려고 할 때 런타임 에러가 발생할 수 있다는 특징을 가지고 있습니다.
따라서 참조하고 있는 객체가 참조자와 같은 수명 또는 더 긴 수명을 가질 때 사용해야 합니다.

마지막 방법은 `클로저 내 캡쳐 리스트(Capture List in Closures)`를 활용하는 방법입니다.

```swift
class MyClass {
    var property: String
    
    init(property: String) {
        self.property = property
    }
    
    func doSomething() {
        someAsyncMethod { [weak self] result in
            guard let strongSelf = self else {
                return
            }
            strongSelf.property = result
        }
    }
}

```

클로저 내에서 `self`를 참조할 때 강한 순환 참조가 발생할 수 있습니다.
그럴 경우 클로저 캡쳐 리스트를 사용하여 클로저가 `self`를 `weak` 또는 `unowned`로 참조하도록 할 수 있습니다.
